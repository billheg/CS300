# CS300
Data Structures and Algorithms course material

(Q) What was the problem you were solving in the projects for this course?
(A) The focus of this course was discussing the pros and cons of various data structures, such as linked lists, vectors, hash tables, and binary search trees. In addition to learning about the mechanics and common examples of these structures, students learned about memory management and Big O notation runtime analysis to evaluate structure suitability in a range of practical applications.

(Q) How did you approach the problem? Consider why data structures are important to understand.
(A) As my high school economics teacher once said, there is no such thing as a free lunch. In the context of computer science, there is always a tradeoff between data retrieval time and storage space complexity. Just like a real-world repository such as a library, the more shelf space there is, the longer it will take to find a particular book. Different data structures have vastly different runtime complexities for common tasks like insertion, search, deletion, etc. Also, computer memory is finite. There is no silver-bullet data structure that is optimal for all cases. Programmers must understand the principles of data structures in order to select the best construct for a given application. 

(Q) How did you overcome any roadblocks you encountered while going through the activities or project?
(A) In previous courses and in my personal projects, I have used JetBrains IDEs such as PyCharm, IntelliJ, and CLion. I continued to use CLion as my IDE of choice for C++ applications. It was very helpful when it came to recognizing syntax errors, debugging, and optimizing the code through ClangTidy suggestions in real time. Occasionally, I encountered error codes in CLion and in the Windows command terminal. I searched StackOverflow and other programming forums to see how other programmers navigated these roadblocks. Most of the time, I found a quick fix. Other times, I spent many hours troubleshooting the issue and eventually decided to start from scratch with a simple "Hello, World" shell that would compile properly. Then I slowly added my own code to that program until I was able to reproduce the error. While it was time consuming, this process often taught me more about the methods and C++ principles I was utilizing that extended beyond the scope of that week's assignment. 


(Q) How has your work on this project expanded your approach to designing software and developing programs?
(A) This project reinforced the importance of readable, modular code.  In the early stages, I spent more time correcting errors in and trying to understand the starter code that was provided. Consistent documentation, good pseudocode, informative variable names, and frequent comments can dramatically speed up the time it takes for a new programmer to understand a project. In a professional setting, this can mean getting a program to a client faster, at a lower cost, or both!  Also, this project has reminded me about the value of revisiting and improving my own past projects. I recycled many classes and methods throughout this project, but had to make sure that I was using a version of my code that actually compiled, and not a failed experiment. 


(Q) How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
(A) The assignments throughout this course focused on two core tasks: loading data from a government auction, and handling a sample course list for a computer science syllabus. Due to the repetitive, but evolving nature of the tasks, much of the code was reused each week with slight adjustments. In the past, I made the mistake of writing one large function that would do 10 different tasks. It might perform well for the one narrow application I envisioned, but was useless in other contexts. I learned that it was much faster to implement code that was narrowly focused - code that did just one specific tasks, but did it quickly, efficiently, and reliably.  This concept, combined with consistent writing styles (naming conventions) and plenty of informative comments will make the code useful for many other implementations outside of this project. 
